    
fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 转移给 s1

    let s2 = String::from("hello");     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到
                                        // takes_and_gives_back 中,
                                        // 它也将返回值移给 s3
    //println!("{s2},{s1}!");  //这里会编译报错m2已被移走
    println!("{s3},{s1}!");
} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
  // 所以什么也不会发生。s1 离开作用域并被丢弃

fn gives_ownership() -> String {             // gives_ownership 会将
                                             // 返回值移动给
                                             // 调用它的函数

    let some_string = String::from("yours"); // some_string 进入作用域.

    some_string                              // 返回 some_string 
                                             // 并移出给调用的函数
                                             // 
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -> String { // a_string 进入作用域
                                                      // 

    a_string  // 返回 a_string 并移出给调用的函数
}

//////////////////////////////////////////////////////////////////////////////////////////////
// 栈与堆：                                                                                 //
// 1. 栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 后进先出（last in, first out）。 //
// 2. 堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。                            //
//     内存分配器（memory allocator）在堆的某处找到一块足够大的空位，                       //
//     把它标记为已使用，并返回一个表示该位置地址的 指针（pointer）。                       //
// 内存回收：                                                                               //
// 1. 如果忘记回收了会浪费内存。                                                            //
// 2. 如果过早回收了，将会出现无效变量。                                                    //
// 3. 如果重复回收，这也是个 bug。                                                          //
// 所有权：                                                                                 //
// 1. Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。                             //
// 2. 值在任一时刻有且只有一个所有者。                                                      //
// 3. 当所有者（变量）离开作用域，这个值将被丢弃。                                          //
// 作用域：                                                                                 //
// 作用域是一个项（item）在程序中有效的范围。                                               //
// 当 s 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。                 //
//  这个函数叫做 drop，在这里 String 的作者可以放置释放内存的代码。                         //
//  CODE：                                                                                  //
//  {                      // s 在这里无效, 它尚未声明                                      //
//      let s = "hello";   // 从此处起，s 是有效的                                          //
//      // 使用 s                                                                           //
//  }                      // 此作用域已结束，s 不再有效                                    //
// 变量与数据交互的方式：                                                                   //
//  1.移动：                                                                                //
//  类似c++的move，实际上是只拷贝栈中的内容。                                               //
//   CODE:                                                                                  //
//   fn main() {                                                                            //
//      let s1 = String::from("hello");                                                     //
//      let s2 = s1;                                                                        //
//      println!("{}, world!", s1);                                                         //
//   }                                                                                      //
//   以上代码无法通过编译：                                                                 //
//   error[E0382]: borrow of moved value: `s1`                                              //
//  2.克隆：                                                                                //
//   CODE:                                                                                  //
//   fn main() {                                                                            //
//      let s1 = String::from("hello");                                                     //
//      let s2 = s1.clone();                                                                //
//      println!("s1 = {}, s2 = {}", s1, s2);                                               //
//   }                                                                                      //
//  以上代码会发生内存堆中的拷贝，会使效率减慢。                                            //
//  只在栈上的数据————拷贝：                                                                //
//   CODE:                                                                                  //
//   fn main() {                                                                            //
//      let x = 5;                                                                          //
//      let y = x;                                                                          //
//      println!("x = {}, y = {}", x, y);                                                   //
//   }                                                                                      //
//  以上代码没有调用 clone，不过 x 依然有效且没有被移动到 y 中。                            //
//   原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，                             //
//   所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效。                 //
//   换句话说，这里没有深浅拷贝的区别，所以这里调用 clone                                   //
//   并不会与通常的浅拷贝有什么不同，我们可以不用管它。                                     //
//  Rust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上（第十章 //
//   详细讲解 trait）。如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后//
//   仍然可用。Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。如果我们 //
//   对其值离开作用域时需要特殊处理的类型使用 Copy 注解，将会出现一个编译时错误。要学习如何 //
//   为你的类型添加 Copy 注解以实现该 trait，请阅读附录 C 中的 “可派生的 trait”。           //
//  这个使用 Copy 注解的类型应该完全在栈上。                                                //
// 所有权与函数：                                                                           //
// 返回值与作用域:                                                                          //
//////////////////////////////////////////////////////////////////////////////////////////////

