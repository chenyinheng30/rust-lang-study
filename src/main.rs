fn main() {
    // 将值传递给函数在语义上与给变量赋值相似。
    let s = String::from("hello");  // s 进入作用域

    println!("{s}");
    takes_ownership(s);             // s 的值移动到函数里 ...
    //println!("{s}");                // ... 所以到这里不再有效
    
    let x = 5;                      // x 进入作用域

    println!("{x}");
    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，
    println!("{x}")                 // 所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 没有特殊之处


fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。
  // 占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。没有特殊之处

//////////////////////////////////////////////////////////////////////////////////////////////
// 栈与堆：                                                                                 //
// 1. 栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 后进先出（last in, first out）。 //
// 2. 堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。                            //
//     内存分配器（memory allocator）在堆的某处找到一块足够大的空位，                       //
//     把它标记为已使用，并返回一个表示该位置地址的 指针（pointer）。                       //
// 内存回收：                                                                               //
// 1. 如果忘记回收了会浪费内存。                                                            //
// 2. 如果过早回收了，将会出现无效变量。                                                    //
// 3. 如果重复回收，这也是个 bug。                                                          //
// 所有权：                                                                                 //
// 1. Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。                             //
// 2. 值在任一时刻有且只有一个所有者。                                                      //
// 3. 当所有者（变量）离开作用域，这个值将被丢弃。                                          //
// 作用域：                                                                                 //
// 作用域是一个项（item）在程序中有效的范围。                                               //
// 当 s 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。                 //
//  这个函数叫做 drop，在这里 String 的作者可以放置释放内存的代码。                         //
//  CODE：                                                                                  //
//  {                      // s 在这里无效, 它尚未声明                                      //
//      let s = "hello";   // 从此处起，s 是有效的                                          //
//      // 使用 s                                                                           //
//  }                      // 此作用域已结束，s 不再有效                                    //
// 变量与数据交互的方式：                                                                   //
//  1.移动：                                                                                //
//  类似c++的move，实际上是只拷贝栈中的内容。                                               //
//   CODE:                                                                                  //
//   fn main() {                                                                            //
//      let s1 = String::from("hello");                                                     //
//      let s2 = s1;                                                                        //
//      println!("{}, world!", s1);                                                         //
//   }                                                                                      //
//   以上代码无法通过编译：                                                                 //
//   error[E0382]: borrow of moved value: `s1`                                              //
//  2.克隆：                                                                                //
//   CODE:                                                                                  //
//   fn main() {                                                                            //
//      let s1 = String::from("hello");                                                     //
//      let s2 = s1.clone();                                                                //
//      println!("s1 = {}, s2 = {}", s1, s2);                                               //
//   }                                                                                      //
//  以上代码会发生内存堆中的拷贝，会使效率减慢。                                            //
//  只在栈上的数据————拷贝：                                                                //
//   CODE:                                                                                  //
//   fn main() {                                                                            //
//      let x = 5;                                                                          //
//      let y = x;                                                                          //
//      println!("x = {}, y = {}", x, y);                                                   //
//   }                                                                                      //
//  以上代码没有调用 clone，不过 x 依然有效且没有被移动到 y 中。                            //
//   原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，                             //
//   所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效。                 //
//   换句话说，这里没有深浅拷贝的区别，所以这里调用 clone                                   //
//   并不会与通常的浅拷贝有什么不同，我们可以不用管它。                                     //
//  Rust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上（第十章 //
//   详细讲解 trait）。如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后//
//   仍然可用。Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。如果我们 //
//   对其值离开作用域时需要特殊处理的类型使用 Copy 注解，将会出现一个编译时错误。要学习如何 //
//   为你的类型添加 Copy 注解以实现该 trait，请阅读附录 C 中的 “可派生的 trait”。           //
//  这个使用 Copy 注解的类型应该完全在栈上。                                                //
// 所有权与函数：                                                                           //
//////////////////////////////////////////////////////////////////////////////////////////////

